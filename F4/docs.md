# 椀から飴玉を減らしていくプログラム

本プログラムは、4つの椀に入った飴玉の数を特定のルールに従って減らしていくシミュレーションを行い、最終的に残った飴玉の総数を計算します。

## プログラムの操作方法

1.  **プログラムの実行:**
    Python環境でこのスクリプトファイルを実行します。
    ```bash
    python script.py
    ```
2.  **入力:**
    プログラムが起動すると、「4個の整数をスペース区切りで入力してください (終了するには0 0 0 0を入力): 」というメッセージが表示されます。
      * **飴玉の数:** 4つの椀に入っている飴玉の数を、スペースで区切って入力します。各数値は0以上100以下の整数である必要があり、かつ全ての椀が同時に0個になることはできません。
        例: `10 8 4 6`
      * **プログラムの終了:** `0 0 0 0` と入力すると、プログラムは終了します。
3.  **出力:**
    有効な入力が与えられると、飴玉の減少プロセスがシミュレートされ、最終的に残った飴玉の総数が1行で表示されます。
    例:
    ```
    4個の整数をスペース区切りで入力してください (終了するには0 0 0 0を入力): 10 8 4 6
    2
    ```

## ユーザー定義関数の説明

### `solve()`

  * **関数名:** `solve`
  * **引数:** なし
  * **戻り値:** なし
  * **処理内容:**
    この関数はプログラムのメインループを制御します。ユーザーからの入力を受け付け、その入力が有効であるかを検証します。入力が `0 0 0 0` であった場合はプログラムを終了します。有効な入力に対しては、`simulate_candy_reduction` 関数を呼び出して飴玉の減少プロセスを実行し、その結果（最終的に残った飴玉の総数）をコンソールに出力します。

### `simulate_candy_reduction(initial_boxes)`

  * **関数名:** `simulate_candy_reduction`
  * **引数:**
      * `initial_boxes` (list): 各椀の初期の飴玉の数を示す整数のリスト（例: `[10, 8, 4, 6]`）。
  * **戻り値:**
      * `int`: 最終的に残る飴玉の総数。
  * **処理内容:**
    この関数は、与えられた初期の飴玉の配置に対して、以下のルールに従って飴玉の減少プロセスをシミュレートします。
    1.  **選択:** 「空でない椀から空でない椀がすべて隣り合う椀が、一番少ない飴玉の数が2つ以上となる箱が、少なくとも1つ以上となるときは、一番左の椀を選ぶ。」というルールに基づき、2つ以上の飴玉を持つ椀の中から、飴玉の数が最も少なく、かつ元の並び順で最も左（インデックスが小さい）の椀を選択します。
    2.  **減少:** 選択された椀以外のすべての椀から、選択された椀の**選ぶ前の**飴玉の数と同数の飴玉を取り除きます。ただし、飴玉の数は0を下回らないようにします。選択された椀の飴玉はそのままにします。
    3.  **並べ替え:** 減少処理後、空になった椀（飴玉が0個になった椀）を除外し、残った空でない椀を飴玉の数が多い順に並べ替えます。その後、全体の椀の数が4つになるように、必要に応じて0を追加してリストを再構成します。
        このプロセスは、以下のいずれかの条件が満たされるまで繰り返されます。
    <!-- end list -->
      * 2つ以上の飴玉を持つ椀が存在しなくなった場合。
      * 空でない椀が1つだけになった場合。
      * すべての椀が空になった場合（合計が0になった場合）。
        最終的に残った飴玉の総数を計算して返します。

## プログラムの工夫点

  * **問題文の厳密な解釈と実装:**
      * 特に複雑なルールである「選んだ椀の中の飴玉はそのままにしておく」という点や、「選んだ椀の飴玉と同数の飴玉を他の椀から取り除く」際の基準（選ぶ前の数）を画像例と照らし合わせながら正確に実装しています。
      * 「一番左の椀を選ぶ」という条件を満たすために、`eligible_boxes` を `(飴玉の数, 元のインデックス)` のタプルでソートし、`eligible_boxes[0]` を選択することで、最小の飴玉数かつ最小のインデックスを持つ椀を確実に選べるようにしています。
  * **状態管理:**
      * `simulate_candy_reduction` 関数内で `initial_boxes` を `list(initial_boxes)` でコピーすることで、元の入力リストを変更しないように配慮しています。
      * 各ステップで空でない椀を抽出し、ソートし、その後再び4つの椀のリストに再構成することで、問題の要件である「空でない腕が1つだけになるまで繰り返す」と「多い順に並べ替える」を両立させています。
  * **堅牢な入力検証:**
      * `solve` 関数内で、ユーザー入力が4つのスペース区切りの整数であるか、各数値が0から100の範囲内であるか、そして全ての椀が同時に空でないか（少なくとも1つは0でないか）を詳細にチェックし、無効な入力に対しては適切なメッセージを表示して再入力を促すことで、プログラムの安定性を高めています。
  * **明確な終了条件:**
      * 飴玉がこれ以上減らせない場合（全ての箱が1個以下になった場合）や、空でない椀が1つだけになった場合に、適切にループを終了させる条件を設けることで、無限ループを防ぎ、正確な最終結果を保証しています。